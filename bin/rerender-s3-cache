#! /app/vendor/node/bin/node

/**

	S3 bucket holds cached rendered endpoints with a prefix
		updating endpoints is a matter of
			changing prefix
			rerendering all of the endpoints in the previous prefix

	there is also a json file that tracks these -- not sure if we are going to use that or not

	how would an endpoint be removed given this setup?

*/

var http = require('http');
var Q = require('q');

var prerenderPrefix = require('./prerenderPrefix');
var currentCachedURLs = require('./currentCachedURLs');

var prerenderURL = process.env.HEROKU_APP_NAME + '.herokuapp.com';

var prefix = '';
if (process.env.S3_PREFIX_KEY) {
		prefix = process.env.S3_PREFIX_KEY;
}
console.log('old prefix: ' + prefix);

var prefixNum = prefix.match(/\d+$/);
if (prefixNum) {
	prefixNum = parseInt(prefixNum[0])+1;
} else {
	prefixNum = 0;
};


var newPrefix = 'prerender_' + prefixNum;
console.log('new prefix: ' + newPrefix);


function handle_object(item) {
	var deferred = Q.defer();
	console.log('got item: ', item);

	http.request({
		hostname: prerenderURL,
		path: '/' + item,
		method: 'GET'
	}, deferred.resolve).end();

	return deferred.promise;
}


function handle_object_result(res) {
	var deferred = Q.defer();
	console.log('statusCode: ', res.statusCode);
	if (res.statusCode != 200) {
		deferred.reject("Did not get a 200");
	}
	deferred.resolve(res.statusCode == 200);
	return deferred.promise;
}


function handle_object_error(err) {
	console.log('error:', err);
	throw new Error(err);
}


function handle_objects(data) {
	console.log('handle_objects: ', data);
	var queue = [];

	for (var item in data) {
		console.log('item: ', item);
		if (data.hasOwnProperty(item)) {
			var endpoints = data[item];
			endpoints.forEach(
				function(endpoint) {
					console.log('item: ', endpoint);
					queue.push(Q.fcall(handle_object, endpoint).then(handle_object_result, handle_object_error));
				}
			);
		}
	}
	return Q.all(queue);
}


function handle_objects_error(err) {
		console.log("handle_objects_error: ", err, err.stack); // an error occurred
		throw 'retry';
}

function retry(promise, maxRetries, retryNum) {
	var delayDuration = 5000;

	// optionally can be called with only the promise and maxRetries defined
	if (typeof retryNum === "undefined") {
		retryNum = 0;
	}

	if (retryNum>maxRetries) {
		console.log("reached max retries");
		return Q(false);
	}

	if (retryNum>0) console.log('retry: ', retryNum);

	return Q().delay(retryNum>0?delayDuration:0)
		.then(function() {return promise();})
		.then(undefined,
			function(err) {
				console.log('got an error, retrying: ', err);
				return retry(promise, maxRetries, retryNum+1);
			});
}

prerenderPrefix.doChangePrefix(newPrefix)
.then(function () { return currentCachedURLs.getCacheMap(prefix); })
.then(function (cacheMap) {
console.log('cacheMap: ', cacheMap);
	promise = function() { return handle_objects(cacheMap) };
	return retry(promise, 5);
}, handle_objects_error)
.then(function (results) {
	console.log('handle objects array: ', results);
	return prerenderPrefix.doChangePrefix(prefix);
})
.done(
	function (args) {
		console.log('exiting: ', args);
		process.exit();
});


// JBT not deleteing these for testing purposes
// s3.deleteObject({Key: key}, function(err, data) {
// 	if (err) console.log(err, err.stack);
// 	else {
// 		console.log(data);
// 	};
// });
